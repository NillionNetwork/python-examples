import asyncio
import os
import pytest
import random
from math import sqrt

from nillion_client import (
    InputPartyBinding,
    Network,
    NilChainPayer,
    NilChainPrivateKey,
    OutputPartyBinding,
    Permissions,
    SecretInteger,
    VmClient,
    PrivateKey,
)
from dotenv import load_dotenv

home = os.getenv("HOME")
load_dotenv(f"{home}/.config/nillion/nillion-devnet.env")


# 1 Party running simple addition on 1 stored secret and 1 compute time secret
async def main():
    # Use the devnet configuration generated by `nillion-devnet`
    network = Network.from_config("devnet")

    # Create payments config and set up Nillion wallet with a private key to pay for operations
    nilchain_key: str = os.getenv("NILLION_NILCHAIN_PRIVATE_KEY_0")  # type: ignore
    payer = NilChainPayer(
        network,
        wallet_private_key=NilChainPrivateKey(bytes.fromhex(nilchain_key)),
        gas_limit=10000000,
    )

    # Use a random key to identify ourselves
    signing_key = PrivateKey()
    client = await VmClient.create(signing_key, network, payer)

    # Adding funds to the client balance so the upcoming operations can be paid for
    funds_amount = 4000000
    print(f"üí∞  Adding some funds to the client balance: {funds_amount} uNIL")
    await client.add_funds(funds_amount)

    party_0_name = "Party0"
    party_1_name = "Party1"
    out_party_name = "OutParty"
    program_name = "correlation_coefficient"
    program_mir_path = f"../nada_programs/target/{program_name}.nada.bin"

    # Store program
    program_mir = open(program_mir_path, "rb").read()
    program_id = await client.store_program(program_name, program_mir).invoke()
    print(f"Stored program_id: {program_id}")

    # Set permissions for the client to compute on the program
    permissions = Permissions.defaults_for_user(client.user_id).allow_compute(
        client.user_id, program_id
    )

    # Config elements
    linear = lambda x: 30 * x + 21
    p0_points = 10
    p1_points = 10
    precision = 5

    random.seed(42)

    # Create inputs for both parties
    party_0_secrets = {}
    for i in range(p0_points):
        party_0_secrets[f"x{i}"] = SecretInteger(i + 1)
        party_0_secrets[f"y{i}"] = SecretInteger(linear(i + 1) + random.randint(0, 10))

    party_1_secrets = {}
    for i in range(p0_points, p0_points + p1_points):
        party_1_secrets[f"x{i}"] = SecretInteger(i + 1)
        party_1_secrets[f"y{i}"] = SecretInteger(linear(i + 1) + random.randint(0, 10))

    # Give core_concept_permissions to owner to compute with my vote
    permissions = Permissions.defaults_for_user(client.user_id).allow_compute(
        client.user_id, program_id
    )

    value_ids = []
    # Store in the network
    print(f"Storing party 0: {party_0_secrets}")

    values_id = await client.store_values(
        party_0_secrets, ttl_days=5, permissions=permissions
    ).invoke()
    value_ids.append(values_id)
    print(f"Stored party 0 with values_id = {values_id}")

    print(f"Storing party 1: {party_1_secrets}")
    values_id = await client.store_values(
        party_1_secrets, ttl_days=5, permissions=permissions
    ).invoke()
    value_ids.append(values_id)
    print(f"Stored party 1 with values_id = {values_id}")

    # Bind the parties in the computation to the client to set input and output parties
    input_bindings = [
        InputPartyBinding(party_0_name, client.user_id),
        InputPartyBinding(party_1_name, client.user_id),
    ]
    output_bindings = [OutputPartyBinding(out_party_name, [client.user_id])]

    # We won't pass in any compute time values as they're all uploaded
    compute_time_values = {}

    print(f"Computing using program {program_id}")
    print(f"Use stored values with ids: {value_ids}")

    # Compute on the secret
    compute_id = await client.compute(
        program_id,
        input_bindings,
        output_bindings,
        values=compute_time_values,
        value_ids=value_ids,
    ).invoke()

    # Print compute result
    print(f"The computation was sent to the network. compute_id: {compute_id}")
    result = await client.retrieve_compute_results(compute_id).invoke()
    print(f"‚úÖ  Compute complete for compute_id {compute_id}")
    print(f"üñ•Ô∏è  The result is {result}")
    corr_coeff_squared = result["correlation_coefficient_squared"].value / 10**precision  # type: ignore
    sign = 1 if result["sign"].value else -1
    corr_coeff = round(sign * sqrt(corr_coeff_squared), precision)
    print(f"üìà  Correlation coefficient = {corr_coeff} with precision {precision}.")
    balance = await client.balance()
    print(f"üí∞  Final client balance: {balance.balance} Credits")
    client.close()
    return result


if __name__ == "__main__":
    asyncio.run(main())


@pytest.mark.asyncio
async def test_main():
    result = await main()
    assert result == {
        "correlation_coefficient_squared": SecretInteger(99958),
        "sign": SecretInteger(1),
    }
