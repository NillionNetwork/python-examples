##########################################################################################

#                                   VOTING  --  PART 3

##########################################################################################

import argparse
import asyncio
import os
from nillion_client import (
    InputPartyBinding,
    Network,
    NilChainPayer,
    NilChainPrivateKey,
    OutputPartyBinding,
    SecretUnsignedInteger,
    UserId,
    VmClient,
    PrivateKey,
)
from dotenv import load_dotenv
from nillion_client.ids import UUID
from config import CONFIG, CONFIG_CANDIDATES, CONFIG_PARTY_1, CONFIG_N_PARTIES

from digest_result import (
    digest_plurality_vote_honest_result,
    digest_plurality_vote_dishonest_with_abort_result,
    digest_plurality_vote_robust_result,
)

home = os.getenv("HOME")
load_dotenv(f"{home}/.config/nillion/nillion-devnet.env")


async def main():
    parser = argparse.ArgumentParser(
        description="Create a secret on the Nillion network with set read/retrieve permissions"
    )
    parser.add_argument(
        "--program_id",
        required=True,
        type=str,
        help="Program ID of the voting program",
    )
    parser.add_argument(
        "--user_ids_to_value_ids",
        required=True,
        nargs="+",
        type=str,
        help="List of userid:valueid pairs of the secrets, with each pair separated by a space",
    )
    parser.add_argument(
        "--program_name",
        required=True,
        type=str,
        help="The name of the program being invoked",
    )

    args = parser.parse_args()

    #####################################
    # 1. Parties initialization         #
    #####################################

    #############################
    # 1.1 Owner initialization  #
    #############################
    # Alice initializes a client
    # Use the devnet configuration generated by `nillion-devnet`
    network = Network.from_config("devnet")

    # Create payments config and set up Nillion wallet with a private key to pay for operations
    nilchain_key: str = os.getenv("NILLION_NILCHAIN_PRIVATE_KEY_0")  # type: ignore
    payer = NilChainPayer(
        network,
        wallet_private_key=NilChainPrivateKey(bytes.fromhex(nilchain_key)),
        gas_limit=10000000,
    )
    signing_key = PrivateKey(CONFIG_PARTY_1["private_key"])

    client = await VmClient.create(signing_key, network, payer)

    #####################################
    # 4. Storing votes                  #
    #####################################
    # Add any computation time secrets
    # Alice provides her vote at compute time

    party_name_alice = CONFIG_PARTY_1["party_name"]
    secret_votes = CONFIG_PARTY_1["secret_votes"]
    secret_votes = {
        key: SecretUnsignedInteger(value) for key, value in secret_votes.items()
    }

    print(f"\nüéâ {party_name_alice} provided her vote as a compute time secret.")

    #####################################
    # 6. Owner execute computation      #
    #####################################
    # Create computation bindings for voting program

    input_bindings = []

    #################################################
    # 6 Bind voter to input party in the program  #
    #################################################
    # Add Alice as an input party

    input_bindings.append(
        InputPartyBinding(CONFIG_PARTY_1["party_role"], client.user_id)
    )

    # Also add Bob and Charlie as input parties
    value_ids = []
    for i, pair in enumerate(args.user_ids_to_value_ids):
        user_id, values_id = pair.split(":")
        party_role = CONFIG_N_PARTIES[i]["party_role"]
        input_bindings.append(InputPartyBinding(party_role, UserId.parse(user_id)))
        value_ids.append(UUID(values_id))

    ##################################################
    # 6.1 Bind owner to output party in the program  #
    ##################################################
    # Create an output party (Alice).
    # The output party reads the result of the blind computation
    output_bindings = [OutputPartyBinding("OutParty", [client.user_id])]

    print(f"Computing using program {args.program_id}")

    # Compute on the secret with all store ids. Note that there are no compute time secrets or public variables
    compute_id = await client.compute(
        args.program_id, input_bindings, output_bindings, secret_votes, value_ids
    ).invoke()

    # Print compute result
    print(f"The computation was sent to the network. compute_id: {compute_id}")
    print("Waiting for computation response...")
    result = await client.retrieve_compute_results(compute_id).invoke()
    print(f"‚úÖ  Compute complete for compute_id {compute_id}")
    print(f"üñ•Ô∏è  The output result is {result}")
    balance = await client.balance()
    print(f"üí∞  Final client balance: {balance.balance}\n")
    client.close()

    # Digest the result
    program_name = args.program_name
    nr_candidates = CONFIG["nr_candidates"]
    nr_voters = CONFIG["nr_voters"]
    voters = CONFIG_N_PARTIES
    voters.insert(0, CONFIG_PARTY_1)
    candidates = CONFIG_CANDIDATES
    if program_name == "voting_dishonest_robust_6":
        print("Let use digest the result given by the network:")
        winner, total_votes, cheaters = digest_plurality_vote_robust_result(
            result, nr_candidates, nr_voters
        )
        winner_name = candidates[winner]
        cheaters_names = [voters[voter]["party_name"] for voter in cheaters]
        print(f"üèÜ Winner is {winner_name}")
        print("üî¢ Total number of votes per candidate:")
        print(f"          Dave: {total_votes[0]}")
        print(f"          Emma: {total_votes[1]}")
        print(f"üïµÔ∏è‚Äç‚ôÇÔ∏è List of cheaters: {cheaters_names}")
    elif program_name in ["voting_honest_1", "voting_honest_2"]:
        digest_plurality_vote_honest_result(result, nr_candidates, nr_voters)
    elif program_name == "voting_dishonest_abort_5":
        digest_plurality_vote_dishonest_with_abort_result(
            result, nr_candidates, nr_voters
        )


asyncio.run(main())
