##########################################################################################

#                                   SINGLE FILE VOTING

##########################################################################################


import hashlib
import asyncio
import os
from nillion_client import (
    Network,
    NilChainPayer,
    NilChainPrivateKey,
    InputPartyBinding,
    OutputPartyBinding,
    Permissions,
    SecretUnsignedInteger,
    VmClient,
    PrivateKey,
)
from dotenv import load_dotenv
from config import CONFIG

from digest_result import (
    digest_plurality_vote_honest_result,
    digest_plurality_vote_dishonest_with_abort_result,
    digest_plurality_vote_robust_result,
)

home = os.getenv("HOME")
load_dotenv(f"{home}/.config/nillion/nillion-devnet.env")


async def main():
    while True:
        # Below, you can choose which voting program to use. In case you choose a voting program
        # different from the robust version ('voting_dishonest_robust_6'), you can complete
        # either 'digest_plurality_vote_honest_result()' or 'digest_plurality_vote_dishonest_with_abort_result()'
        # functions above to digest the result.
        #
        # Existing voting nada_programs:
        #
        # program_name = "voting_honest_1"
        # program_name = "voting_honest_2"
        # program_name = "voting_dishonest_abort_5"
        # program_name = "voting_dishonest_robust_6"

        print("Choose a program to test:")
        print("1. voting_honest_1")
        print("2. voting_honest_2")
        print("3. voting_dishonest_abort_5")
        print("4. voting_dishonest_robust_6")

        choice = input("Enter the number corresponding to your choice: ")

        programs = {
            "1": "voting_honest_1",
            "2": "voting_honest_2",
            "3": "voting_dishonest_abort_5",
            "4": "voting_dishonest_robust_6",
        }

        if choice in programs:
            program_name = programs[choice]
            print("You have chosen:", program_name)
            print(" _         _   _                  _                  _ _   _     ")
            print("| |    ___| |_( )___  __   _____ | |_ ___  __      _(_) |_| |__  ")
            print(
                "| |   / _ \\ __|// __| \\ \\ / / _ \\| __/ _ \\ \\ \\ /\\ / / | __| '_ \\ "
            )
            print(
                "| |__|  __/ |_  \\__ \\  \\ V / (_) | ||  __/  \\ V  V /| | |_| | | |"
            )
            print(
                "|_____\\___|\\__| |___/   \\_/_\\___/ \\__\\___|   \\_/\\_/ |_|\\__|_| |_|"
            )
            print("                    _____(_) | (_) ___  _____| |                 ")
            print("                   |  _  | | | | |/ _ \\|  _  | |                 ")
            print("                   | | | | | | | | (_) | | | |_|                 ")
            print("                   |_| |_|_|_|_|_|\\___/|_| |_(_)                 ")
            print("                                                                 ")
            break  # Exit the loop if a valid choice is made
        else:
            print("Invalid choice. Please enter a number between 1 and 4.")

    # We initialize one party 'general_client' that represents all different parties.
    #
    # In a real environment, the clients must run in different machines with
    # different node and user keys.
    #
    # The script has the following flow:
    #     1. Parties initialization
    #     2. Owner stores a program.
    #     3. (Real environment:) Owner sends the program ID to all voters.
    #     4. Voters store votes:
    #         4.1 Bind voter to party in the program
    #         4.2 Set compute permission to owner
    #     5. (Real environment:) Voters send their their party IDs and store IDs to the owner.
    #     6. Owner compute voting system using votes from voters.

    nr_candidates = CONFIG["nr_candidates"]
    nr_voters = CONFIG["nr_voters"]

    #####################################
    # 1. Parties initialization         #
    #####################################

    ######################################
    # 1.0 General client initialization  #
    ######################################
    # Use the devnet configuration generated by `nillion-devnet`
    network = Network.from_config("devnet")

    # Create payments config and set up Nillion wallet with a private key to pay for operations
    nilchain_key: str = os.getenv("NILLION_NILCHAIN_PRIVATE_KEY_0")  # type: ignore
    payer = NilChainPayer(
        network,
        wallet_private_key=NilChainPrivateKey(bytes.fromhex(nilchain_key)),
        gas_limit=10000000,
    )
    seed = b"my_seed"
    signing_key = PrivateKey(hashlib.sha256(seed).digest())

    general_client = await VmClient.create(signing_key, network, payer)

    #####################################
    # 2. Storing program                #
    #####################################

    # Note: do not forget to compile the nada_programs and store the corresponding .nada.bin file.
    program_mir_path = f"../nada_programs/target/{program_name}.nada.bin"
    if not os.path.exists(program_mir_path):
        raise FileNotFoundError(
            f"The file '{program_mir_path}' does not exist.\nMake sure you compiled the PyNada programs with './compile_programs.sh'.\nCheck README.md for more details."
        )

    # Store program in the Network
    print(f"Storing program in the network: {program_name}")
    program = open(program_mir_path, "rb").read()
    program_id = await general_client.store_program(program_name, program).invoke()
    print(f"Program id is: {program_id}")

    #####################################
    # 3. Send program ID                #
    #####################################

    # This requires its own mechanism in a real environment.
    # In this demo, we just reuse the variable 'program_id'.

    #####################################
    # 4. Storing votes                  #
    #####################################

    # Each voter stores its vote. In this demo, we assume each voter has a file
    # containing their votes for each candidate. E.g. voter 0 has a file 'inputs/v0_input.txt'
    # with the following format:
    #  ==============
    #  1
    #  2
    #  ==============
    #  This means, voter 0 assigns 1 to candidate 0 and 2 to candidate 1.

    # Voters store the secrets
    value_ids = []
    for v in range(nr_voters):
        voter_v = general_client
        # voter_v = voters[v]
        print("voter_v: ", voter_v)
        # structure v's votes
        v_vote_values = {}
        v_input_file = "inputs/v" + str(v) + "_input.txt"
        with open(v_input_file, "r") as file:
            c = 0
            for line in file:
                # Remove leading and trailing whitespaces, then convert to integer
                v_c_vote_value = int(line.strip())
                v_c_vote = SecretUnsignedInteger(v_c_vote_value)
                v_vote_values["v" + str(v) + "_c" + str(c)] = v_c_vote
                c += 1

        ###########################################
        # 4.2 Set compute permissions to owner    #
        ###########################################
        # Give permissions to owner to compute with my vote
        v_permissions = Permissions.defaults_for_user(voter_v.user_id).allow_compute(
            general_client.user_id, program_id
        )

        # Store in the network
        print("Storing vote by voter " + str(v) + f": {v_vote_values}")
        values_id = await voter_v.store_values(
            v_vote_values, ttl_days=5, permissions=v_permissions
        ).invoke()
        value_ids.append(values_id)
        print(f"Stored vote by voter {v} with values_id={values_id}")

    #####################################
    # 5. Send party IDs and store IDs   #
    #####################################

    # This requires its own mechanism in a real environment.
    # In this demo, we just reuse the variable 'store_ids' and
    # the voters' clients to extra their party IDs.

    #####################################
    # 6. Owner execute computation      #
    #####################################

    #################################################
    # 6.1 Bind voter to input party in the program  #
    #################################################
    input_bindings = []
    for v in range(nr_voters):
        input_bindings.append(InputPartyBinding(f"Voter{v}", general_client.user_id))

    ##################################################
    # 6.2 Bind owner to output party in the program  #
    ##################################################
    # Bind the "OutParty" party in the computation to the owner's client
    output_bindings = [OutputPartyBinding("OutParty", [general_client.user_id])]

    # No secret is directly passed to 'compute'. It only uses
    # stored secrets.
    to_be_used_in_computation = {}

    print(f"Computing using program {program_id}")
    print(f"Stored secrets: {value_ids}")
    print(f"Provided secret: {to_be_used_in_computation}")

    # Owner can execute the computation
    # compute_id = await owner.compute(
    compute_id = await general_client.compute(
        program_id,
        input_bindings,
        output_bindings,
        values=to_be_used_in_computation,
        value_ids=value_ids,
    ).invoke()

    print(f"Computation sent to the network, compute_id = {compute_id}")
    print("Waiting computation response...")
    result = await general_client.retrieve_compute_results(compute_id).invoke()
    print(f"‚úÖ  Compute complete for compute_id {compute_id}")
    print(f"üñ•Ô∏è  The result is: {result}\n")

    if program_name == "voting_dishonest_robust_6":
        print("Let use digest the result given by the network:")
        winner, total_votes, cheaters = digest_plurality_vote_robust_result(
            result, nr_candidates, nr_voters
        )
        print(f"üèÜ Winner is candidate with ID={winner}")
        print(f"üî¢ Total number of votes per candidate: {total_votes}")
        print(f"üïµÔ∏è‚Äç‚ôÇÔ∏è List of cheaters' IDs: {cheaters}")
    elif program_name in ["voting_honest_1", "voting_honest_2"]:
        digest_plurality_vote_honest_result(result, nr_candidates, nr_voters)
    elif program_name == "voting_dishonest_abort_5":
        digest_plurality_vote_dishonest_with_abort_result(
            result, nr_candidates, nr_voters
        )


asyncio.run(main())
