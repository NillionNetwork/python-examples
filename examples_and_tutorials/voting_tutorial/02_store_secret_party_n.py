##########################################################################################

#                                   VOTING  --  PART 2

##########################################################################################

import argparse
import asyncio
import os
from nillion_client import (
    Network,
    NilChainPayer,
    NilChainPrivateKey,
    Permissions,
    SecretUnsignedInteger,
    UserId,
    VmClient,
    PrivateKey,
)
from dotenv import load_dotenv
from config import CONFIG_N_PARTIES

home = os.getenv("HOME")
load_dotenv(f"{home}/.config/nillion/nillion-devnet.env")


# Bob and Charlie store their votes in the network
async def main():
    parser = argparse.ArgumentParser(
        description="Create a secret on the Nillion network with set read/retrieve permissions"
    )
    parser.add_argument(
        "--user_id_1",
        required=True,
        type=str,
        help="User ID of the user who will compute with the secret being stored",
    )
    parser.add_argument(
        "--program_id",
        required=True,
        type=str,
        help="Program ID of the voting program",
    )
    parser.add_argument(
        "--program_name",
        required=True,
        type=str,
        help="The name of the program being invoked",
    )

    args = parser.parse_args()

    # Use the devnet configuration generated by `nillion-devnet`
    network = Network.from_config("devnet")

    # Create payments config and set up Nillion wallet with a private key to pay for operations
    nilchain_key: str = os.getenv("NILLION_NILCHAIN_PRIVATE_KEY_0")  # type: ignore
    payer = NilChainPayer(
        network,
        wallet_private_key=NilChainPrivateKey(bytes.fromhex(nilchain_key)),
        gas_limit=10000000,
    )

    alice_user_id = UserId.parse(args.user_id_1)

    # start a list of store ids to keep track of stored secrets
    value_ids = []
    user_ids = []

    for party_info in CONFIG_N_PARTIES:
        #####################################
        # 1. Parties initialization         #
        #####################################

        #############################
        # 1.2 Voters initialization #
        #############################

        signing_key = PrivateKey(party_info["private_key"])
        client = await VmClient.create(signing_key, network, payer)

        user_id_n = client.user_id
        party_name = party_info["party_name"]
        secret_votes = party_info["secret_votes"]

        # Adding funds to the client balance so the upcoming operations can be paid for
        funds_amount = 1000
        print(f"üí∞  Adding some funds to the client balance for {party_name}: {funds_amount}")
        await client.add_funds(funds_amount)

        #####################################
        # 4. Storing votes                  #
        #####################################
        # Create a secret for the current party
        secret_votes = {
            key: SecretUnsignedInteger(value) for key, value in secret_votes.items()
        }

        ###########################################
        # 4.2 Set compute permissions to owner    #
        ###########################################
        # Create permissions object with default permissions for the current user
        permissions = Permissions.defaults_for_user(user_id_n)

        # Give compute permissions to Alice so she can use the secret in the specific voting program by program id
        permissions.allow_compute(alice_user_id, args.program_id)
        print(
            f"\nüëç {party_name} gives compute permissions on their secret to Alice's user_id: {alice_user_id}"
        )

        # Store the permissioned secret
        values_id = await client.store_values(
            secret_votes, ttl_days=5, permissions=permissions
        ).invoke()

        value_ids.append(values_id)
        user_ids.append(client.user_id)

        print(f"\nüéâ {party_name} stored its vote at store id: {values_id}\n--------------------------------")

    #####################################
    # 5. Send party IDs and store IDs   #
    #####################################

    # This requires its own mechanism in a real environment.
    user_ids_to_value_ids = " ".join(
        [f"{user_id}:{values_id}" for user_id, values_id in zip(user_ids, value_ids)]
    )

    print(
        "\nüìã‚¨áÔ∏è  Copy and run the following command to run multi party computation using the secrets"
    )
    print(
        f"\npython3 03_multi_party_compute.py --program_id {args.program_id} "
        f"--user_ids_to_value_ids {user_ids_to_value_ids} --program_name {args.program_name}"
    )


asyncio.run(main())
