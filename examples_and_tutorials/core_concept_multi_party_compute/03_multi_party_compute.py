import argparse
import asyncio
import os

from nillion_client import (
    InputPartyBinding,
    Network,
    NilChainPayer,
    NilChainPrivateKey,
    OutputPartyBinding,
    SecretInteger,
    UserId,
    VmClient,
    PrivateKey,
)
from dotenv import load_dotenv
from nillion_client.ids import UUID

from config import CONFIG_PARTY_1, CONFIG_N_PARTIES

home = os.getenv("HOME")

load_dotenv(f"{home}/.config/nillion/nillion-devnet.env")


async def main(args=None):
    parser = argparse.ArgumentParser(
        description="Create a secret on the Nillion network with set read/retrieve permissions"
    )

    parser.add_argument(
        "--user_ids_to_values_ids",
        required=True,
        nargs="+",
        type=str,
        help="List of userid:valuesid pairs of the secrets, with each pair separated by a space",
    )
    parser.add_argument(
        "--program_id",
        required=True,
        type=str,
        help="The id of the program that will run on the uploaded secrets",
    )

    args = parser.parse_args(args)

    # Use the devnet configuration generated by `nillion-devnet`
    network = Network.from_config("devnet")

    # Create payments config and set up Nillion wallet with a private key to pay for operations
    nilchain_key: str = os.getenv("NILLION_NILCHAIN_PRIVATE_KEY_0")  # type: ignore
    payer = NilChainPayer(
        network,
        wallet_private_key=NilChainPrivateKey(bytes.fromhex(nilchain_key)),
        gas_limit=10000000,
    )
    # Use the same identity we used originally to upload the program
    signing_key = PrivateKey(CONFIG_PARTY_1["private_key"])
    client = await VmClient.create(signing_key, network, payer)

    print(f"Computing using program {args.program_id}")

    # Construct the input party bindings.
    input_bindings = []
    values_ids = []
    for i, pair in enumerate(args.user_ids_to_values_ids):
        user_id, values_id = pair.split(":")
        party_name = CONFIG_N_PARTIES[i]["party_name"]
        input_bindings.append(InputPartyBinding(party_name, UserId.parse(user_id)))
        values_ids.append(UUID(values_id))

    # Bind ourselves as an input party since we're also providing some inputs
    input_bindings.append(
        InputPartyBinding(CONFIG_PARTY_1["party_name"], client.user_id)
    )

    # We are the only output party
    output_bindings = [
        OutputPartyBinding(CONFIG_PARTY_1["party_name"], [client.user_id])
    ]

    # The values that this party provides
    values = {
        key: SecretInteger(value) for key, value in CONFIG_PARTY_1["secrets"].items()
    }
    compute_id = await client.compute(
        program_id=args.program_id,
        input_bindings=input_bindings,
        output_bindings=output_bindings,
        values=values,
        value_ids=values_ids,
    ).invoke()

    print(f"The computation was sent to the network. compute_id: {compute_id}")

    # Wait for execution to end
    result = await client.retrieve_compute_results(compute_id).invoke()
    print(f"‚úÖ  Compute complete for compute_id {compute_id}")
    print(f"üñ•Ô∏è  The result is {result}")
    return result


if __name__ == "__main__":
    asyncio.run(main())
